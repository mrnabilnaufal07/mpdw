---
title: "Pertemuan 3 - Regresi dengan Peubah Lag"
author: Nabil Naufal (G1401211008)
output:
  html_document:
    theme: yeti
    toc: true
    toc_float: true
  word_document: default
  pdf_document: default
---

## *Library yang digunakan*
```{r, echo=FALSE}
library(dLagM)
library(dynlm)
library(MLmetrics)
library(lmtest)
library(car)
```

## Impor Data
Peubah respon: AQI
Peubah penjelas: o3
```{r}
data <- rio::import("https://raw.githubusercontent.com/mrnabilnaufal07/mpdw/main/Pertemuan%202/NewDelhi_Air_quality.csv")
Yt = data$AQI
Xt = data$o3
data = data.frame(Yt,Xt)
str(data)
data
```

## Pembagian Data
```{r}
#Split data dengan proporsi: 80% training dan 20% testing
train<-data[1:57,] # 80% data pertama
test<-data[58:72,] # 20% data sisanya
```

Mengubah format data menjadi time series
```{r}
#data time series
train.ts<-ts(train)
test.ts<-ts(test)
data.ts<-ts(data)
```

## Model Koyck

Model Koyck didasarkan pada asumsi bahwa semakin jauh jarak lag peubah independen dari periode sekarang maka semakin kecil pengaruh peubah lag terhadap peubah dependen.

Koyck mengusulkan suatu metode untuk menduga model dinamis distributed lag dengan mengasumsikan bahwa semua koefisien $\beta$ mempunyai tanda sama.

Model kyock merupakan jenis paling umum dari model infinite distributed lag dan juga dikenal sebagai geometric lag

$$
y_t=a(1-\lambda)+\beta_0X_t+\beta_1Z_t+\lambda Y_{t-1}+V_t
$$

dengan $$V_t=u_t-\lambda u_{t-1}$$

### Pemodelan

Pemodelan model Koyck dengan `R` dapat menggunakan `dLagM::koyckDlm()` . Fungsi umum dari `koyckDlm` adalah sebagai berikut.

```{r, eval=FALSE, message = FALSE, warning=FALSE, error=FALSE}
koyckDlm(x , y , intercept)
```

Fungsi `koyckDlm()` akan menerapkan model lag terdistribusi dengan transformasi Koyck satu prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). `intercept` dapat dibuat `TRUE` untuk memasukkan intersep ke dalam model.

```{r}
#MODEL KOYCK
model.koyck <- koyckDlm(x = train$Xt, y = train$Yt)
summary(model.koyck)
AIC(model.koyck)
BIC(model.koyck)
```

Dari hasil tersebut, didapat bahwa peubah $x_t$ dan $y_{t-1}$ memiliki nilai $P-Value<0.05$. Hal ini menunjukkan bahwa peubah $x_t$ dan $y_{t-1}$ berpengaruh signifikan terhadap $y$. Adapun model keseluruhannya adalah sebagai berikut

$$
\hat{Y_t}=-3.7335+1.1510X_t+0.4214Y_{t-1}
$$

### Peramalan dan Akurasi

Berikut adalah hasil peramalan y untuk 15 periode kedepan menggunakan model koyck

```{r}
#h =15, merupakan 15 periode yang akan diprediksi selanjutnya
fore.koyck <- forecast(model = model.koyck, x=test$Xt, h=15)
fore.koyck

#akurasi data testing
mape.koyck <- MAPE(fore.koyck$forecasts, test$Yt)
mape.koyck

#akurasi data training
GoF(model.koyck)
```

## Regression with Distributed Lag

Pemodelan model Regression with Distributed Lag dengan `R` dapat menggunakan `dLagM::dlm()` . Fungsi umum dari `dlm` adalah sebagai berikut.

```{r, eval=FALSE, error=FALSE}
dlm(formula , data , x , y , q , remove )
```

Fungsi `dlm()` akan menerapkan model lag terdistribusi dengan satu atau lebih prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). $q$ adalah integer yang mewakili panjang *lag* yang terbatas.

### Pemodelan (Lag=2)
Ctt: Nilai Lag 2 dipilih secara acak sebagai pembanding untuk pemodelan dengan
lag yang optimum
```{r}
model.dlm <- dlm(x = train$Xt,y = train$Yt , q = 2)
summary(model.dlm)
AIC(model.dlm)
BIC(model.dlm)
```

Dari hasil diatas, didapat bahwa $P-value$ dari $x_{t-1}<0.05$. Hal ini menunjukkan bahwa $x_{t-1}$ berpengaruh signifikan terhadap $y$. Adapun model keseluruhan yang terbentuk adalah sebagai berikut

$$
\hat{Y_t}=-0.052782+0.476379X_t-0.005756X_{t-1}-0.008392X_{t-2}
$$

### Peramalan dan Akurasi

Berikut merupakan hasil peramalan $y$ untuk 15 periode kedepan

```{r}
fore.dlm <- forecast(model = model.dlm, x=test$Xt, h=15)
fore.dlm

#akurasi data testing
mape.dlm <- MAPE(fore.dlm$forecasts, test$Yt); mape.dlm

#akurasi data training
GoF(model.dlm)
```

### *Lag* Optimum
Untuk lag optimum digunakan `q.min=1` dan `q.max=30`. Untuk nilainya sendiri
berasal dari perkiraan saja. Kita mencari hingga diperoleh iterasi yang
memaksimumkan nilai `R.Adj.Sq`nya.
```{r}
#penentuan lag optimum 
finiteDLMauto(formula = Yt ~ Xt,
              data = data.frame(train), q.min = 1, q.max = 30,
              model.type = "dlm", error.type = "AIC", trace = FALSE)
```
Pada iterasi ke `28` diperoleh nilai `-inF` untuk `AIC` dan `BIC` nya serta `NaN` 
pada `R.Adj.Sq`. Oleh karena itu, akan dipilih iterasi ke-27 sebagai lag optimum.
Selanjutnya dilakukan pemodelan untuk lag=27

```{r}
#model dlm dengan lag optimum
model.dlm2 <- dlm(x = train$Xt,y = train$Yt , q = 27) #nilai q diganti dengan lag optimum yang diperoleh pada langkah sebelumnya
summary(model.dlm2)
AIC(model.dlm2)
BIC(model.dlm2)
```

Dari hasil tersebut terdapat beberapa peubah yang berpengaruh signifikan terhadap taraf nyata 10% yaitu $x_t$ , $x_{t-8}$ , $x_{t-9}$ , $x_{t-11}$, dan $x_{t-23}$. Adapun keseluruhan model yang terbentuk adalah

$$
\hat{Y_t}=52.25144 + 0.67298X_t+...-0.24443X_{t-27}
$$

Adapun hasil peramalan 15 periode kedepan menggunakan model tersebut adalah sebagai berikut

```{r}
#peramalan dan akurasi
fore.dlm2 <- forecast(model = model.dlm2, x=test$Xt, h=15)

#akurasi data testing
mape.dlm2<- MAPE(fore.dlm2$forecasts, test$Yt)

#akurasi data training
GoF(model.dlm2)
```

Model tersebut merupakan model yang sangat baik dengan nilai MAPE yang kurang dari 10%.

## Model Autoregressive

Peubah dependen dipengaruhi oleh peubah independen pada waktu sekarang, serta dipengaruhi juga oleh peubah dependen itu sendiri pada satu waktu yang lalu maka model tersebut disebut *autoregressive* (Gujarati 2004).

### Pemodelan

Pemodelan Autoregressive dilakukan menggunakan fungsi `dLagM::ardlDlm()` . Fungsi tersebut akan menerapkan *autoregressive* berordo $(p,q)$ dengan satu prediktor. Fungsi umum dari `ardlDlm()` adalah sebagai berikut.

```{r, eval=FALSE}
ardlDlm(formula = NULL , data = NULL , x = NULL , y = NULL , p = 1 , q = 1 , 
         remove = NULL )
```

Dengan $p$ adalah integer yang mewakili panjang *lag* yang terbatas dan $q$ adalah integer yang merepresentasikan ordo dari proses *autoregressive*.

```{r}
model.ardl <- ardlDlm(x = train$Xt, y = train$Yt, p = 13 , q = 2)
summary(model.ardl)
AIC(model.ardl)
BIC(model.ardl)
```

Hasil di atas menunjukkan bahwa selain peubah $x_{t-1}$, hasil uji t menunjukkan nilai-p pada peubah $\ge0.05$ Hal ini menunjukkan bahwa peubah $x_{t-1}$, $x_{t-1}$ dan $y_{t-1}$ berpengaruh signifikan terhadap $y_t$. Model keseluruhannya adalah sebagai berikut:

$$
\hat{Y}=-0.14906+0.47821X_t-0.22331X_{t-1}+0.45264Y_{t-1}
$$

### Peramalan dan Akurasi

```{r}
fore.ardl <- forecast(model = model.ardl, x=test$Xt, h=15)
fore.ardl
```

Data di atas merupakan hasil peramalan untuk 15 periode ke depan menggunakan Model Autoregressive dengan $p=1$ dan $q=1$.

```{r}
#akurasi data testing
mape.ardl <- MAPE(fore.ardl$forecasts, test$Yt)
mape.ardl

#akurasi data training
GoF(model.ardl)
```

Berdasarkan akurasi di atas, terlihat bahwa nilai MAPE keduanya tidak jauh berbeda. Artinya, model regresi dengan distribusi lag ini tidak `overfitted` atau `underfitted`

### *Lag* Optimum

```{r}
#penentuan lag optimum
model.ardl.opt <- ardlBoundOrders(data = data.frame(data), ic = "AIC", 
                                  formula = Yt ~ Xt )
min_p=c()
for(i in 1:15){
  min_p[i]=min(model.ardl.opt$Stat.table[[i]])
}
q_opt=which(min_p==min(min_p, na.rm = TRUE))
p_opt=which(model.ardl.opt$Stat.table[[q_opt]] == 
              min(model.ardl.opt$Stat.table[[q_opt]], na.rm = TRUE))
data.frame("q_optimum" = q_opt, "p_optimum" = p_opt, 
           "AIC"=model.ardl.opt$min.Stat)
```

Dari tabel di atas, dapat terlihat bahwa nilai AIC terendah didapat ketika $p=13$ dan $q=2$, yaitu sebesar `16.55044	`. Artinya, model autoregressive optimum didapat ketika $p=13$ dan $q=2$.

Selanjutnya dapat dilakukan pemodelan dengan nilai $p$ dan $q$ optimum seperti inisialisasi di langkah sebelumnya.

## Perbandingan Model

```{r}
akurasi <- matrix(c(mape.koyck, mape.dlm, mape.dlm2, mape.ardl))
row.names(akurasi)<- c("Koyck","DLM 1","DLM 2","Autoregressive")
colnames(akurasi) <- c("MAPE")
akurasi
```

Berdasarkan nilai MAPE, model paling optimum didapat pada Model DLM 1 karena memiliki nilai MAPE yang terkecil.

### Plot

```{r}
ss```

Berdasarkan plot tersebut, terlihat bahwa plot yang paling mendekati data aktualnya adalah Model koyck, sehingga dapat disimpulkan model terbaik dalam hal ini adalah model regresi koyck

## Pengayaan (Regresi Berganda)

### Data

```{r}
data(M1Germany)
data1 = M1Germany[1:144,]
```

### DLM

```{r}
#Run the search over finite DLMs according to AIC values
finiteDLMauto(formula = logprice ~ interest+logm1,
              data = data.frame(data1), q.min = 1, q.max = 5,
              model.type = "dlm", error.type = "AIC", trace = FALSE)
```

```{r}
#model dlm berganda
model.dlmberganda = dlm(formula = logprice ~ interest + logm1,
                data = data.frame(data1) , q = 5)
summary(model.dlmberganda)

model.dlmberganda2 = dlm(formula = logprice ~ interest + logm1,
                        data = data.frame(data1) , q = 1)
summary(model.dlmberganda2)
```

### ARDL

```{r}
#Mencari orde lag optimum model ARDL
ardlBoundOrders(data = data1 , formula = logprice ~ interest + logm1,
                ic="AIC")

model.ardlDlmberganda = ardlDlm(formula = logprice ~ interest + logm1,
                        data = data.frame(data1) , p = 4 , q = 4)
summary(model.ardlDlmberganda)
```

```{r}
#model p interest 0 p logm1 4 
rem.p = list(interest = c(1,2,3,4))
remove = list(p = rem.p)
model.ardlDlmberganda2 = ardlDlm(formula = logprice ~ interest + logm1,
                        data = data.frame(data1) , p = 4 , q = 4 ,
                        remove = remove)
summary(model.ardlDlmberganda2)
```

Proses selanjutnya sama dengan pemodelan menggunakan peubah tunggal.